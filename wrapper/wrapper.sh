#!/bin/bash
# ═══════════════════════════════════════════════════════════════════════════════
# ClueMaster Timer Display - Linux/SNAP Wrapper Script
# ═══════════════════════════════════════════════════════════════════════════════
#
# This script:
# 1. Configures ALSA audio with dmix for concurrent audio streams
# 2. Sets up environment variables for Wayland/ubuntu-frame
# 3. Unmutes audio outputs
# 4. Launches Electron via apulse (PulseAudio emulation over ALSA)
#
# dmix is REQUIRED so that multiple audio streams (background music + clue
# alert + TTS speech + video audio) can play simultaneously without
# "Device or resource busy" errors.
# ═══════════════════════════════════════════════════════════════════════════════

set -e

echo "=== ClueMaster Timer Display Wrapper ==="
echo "SNAP=$SNAP"
echo "SNAP_USER_DATA=$SNAP_USER_DATA"

# ─── Ensure temp directory exists ──────────────────────────────────────────────
mkdir -p "$SNAP_USER_DATA/tmp"
export TMPDIR="$SNAP_USER_DATA/tmp"

# ─── D-Bus workaround ─────────────────────────────────────────────────────────
# Chromium/Electron tries to connect to D-Bus for accessibility (AT-SPI2).
# On Ubuntu Core there is no session bus. Unset the variable so Chromium
# does NOT try to parse an empty address string (which causes a crash).
unset DBUS_SESSION_BUS_ADDRESS 2>/dev/null || true
export NO_AT_BRIDGE=1
export GTK_A11Y=none
export AT_SPI2_CORE_NO_DBUS=1

# ─── ALSA / dmix Audio Configuration ──────────────────────────────────────────
ASOUNDRC="$SNAP_USER_DATA/.asoundrc"

echo "Detecting audio devices..."

# Auto-detect available PCM devices from /proc/asound/pcm
HAS_ANALOG=0; HAS_USB_AUDIO=0; HAS_HDMI0=0; HAS_HDMI1=0; HAS_HDMI2=0

if [ -f /proc/asound/pcm ]; then
    echo "Available PCM devices:"
    cat /proc/asound/pcm
    grep -q "^00-00:.*playback" /proc/asound/pcm && HAS_ANALOG=1
    grep -q "^01-00:.*playback" /proc/asound/pcm && HAS_USB_AUDIO=1
    grep -q "^00-03:.*playback" /proc/asound/pcm && HAS_HDMI0=1
    grep -q "^00-07:.*playback" /proc/asound/pcm && HAS_HDMI1=1
    grep -q "^00-08:.*playback" /proc/asound/pcm && HAS_HDMI2=1
else
    echo "WARNING: /proc/asound/pcm not found"
fi

DEVICE_COUNT=$((HAS_ANALOG + HAS_USB_AUDIO + HAS_HDMI0 + HAS_HDMI1 + HAS_HDMI2))
echo "Detected $DEVICE_COUNT audio output(s): analog=$HAS_ANALOG usb=$HAS_USB_AUDIO hdmi0=$HAS_HDMI0 hdmi1=$HAS_HDMI1 hdmi2=$HAS_HDMI2"

# Generate .asoundrc with dmix for each detected device
# Each dmix MUST have a UNIQUE ipc_key for shared memory!

if [ $DEVICE_COUNT -ge 3 ]; then
    echo "Configuring multi-output audio with dmix (3+ devices)..."
    # Build the multi-output config dynamically
    cat > "$ASOUNDRC" << 'ASOUND_HEADER'
# ALSA config - auto-generated by ClueMaster Timer Display wrapper
# dmix enables concurrent audio streams (background music + alerts + TTS)
ASOUND_HEADER

    # Add dmix + plug for each detected device
    if [ $HAS_ANALOG -eq 1 ]; then
        cat >> "$ASOUNDRC" << 'EOF'
pcm.dmix_analog {
    type dmix
    ipc_key 1024
    slave { pcm "hw:0,0"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.plug_analog { type plug; slave.pcm "dmix_analog" }
EOF
    fi

    if [ $HAS_USB_AUDIO -eq 1 ]; then
        cat >> "$ASOUNDRC" << 'EOF'
pcm.dmix_usb {
    type dmix
    ipc_key 1025
    slave { pcm "hw:1,0"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.plug_usb { type plug; slave.pcm "dmix_usb" }
EOF
    fi

    if [ $HAS_HDMI0 -eq 1 ]; then
        cat >> "$ASOUNDRC" << 'EOF'
pcm.dmix_hdmi0 {
    type dmix
    ipc_key 1026
    slave { pcm "hw:0,3"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.plug_hdmi0 { type plug; slave.pcm "dmix_hdmi0" }
EOF
    fi

    if [ $HAS_HDMI1 -eq 1 ]; then
        cat >> "$ASOUNDRC" << 'EOF'
pcm.dmix_hdmi1 {
    type dmix
    ipc_key 1027
    slave { pcm "hw:0,7"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.plug_hdmi1 { type plug; slave.pcm "dmix_hdmi1" }
EOF
    fi

    if [ $HAS_HDMI2 -eq 1 ]; then
        cat >> "$ASOUNDRC" << 'EOF'
pcm.dmix_hdmi2 {
    type dmix
    ipc_key 1028
    slave { pcm "hw:0,8"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.plug_hdmi2 { type plug; slave.pcm "dmix_hdmi2" }
EOF
    fi

    # Build multi-output route device
    # Determine slave list and routing table dynamically
    SLAVE_IDX=0
    SLAVE_LETTERS=("a" "b" "c" "d" "e")
    MULTI_SLAVES=""
    MULTI_BINDINGS=""
    TTABLE=""
    
    for dev in analog usb hdmi0 hdmi1 hdmi2; do
        var="HAS_$(echo $dev | tr '[:lower:]' '[:upper:]')"
        # Bash indirection
        eval "has_dev=\$$var" 2>/dev/null || has_dev=0
        if [ "$has_dev" = "1" ] 2>/dev/null; then
            letter=${SLAVE_LETTERS[$SLAVE_IDX]}
            chan_start=$((SLAVE_IDX * 2))
            MULTI_SLAVES="${MULTI_SLAVES}        slaves.${letter}.pcm \"plug_${dev}\"\n        slaves.${letter}.channels 2\n"
            MULTI_BINDINGS="${MULTI_BINDINGS}        bindings.${chan_start}.slave ${letter}\n        bindings.${chan_start}.channel 0\n        bindings.$((chan_start+1)).slave ${letter}\n        bindings.$((chan_start+1)).channel 1\n"
            TTABLE="${TTABLE}    ttable.0.${chan_start} 1\n    ttable.1.$((chan_start+1)) 1\n"
            SLAVE_IDX=$((SLAVE_IDX + 1))
        fi
    done
    
    printf "pcm.multi_out {\n    type route\n    slave.pcm {\n        type multi\n${MULTI_SLAVES}${MULTI_BINDINGS}    }\n${TTABLE}}\n\npcm.!default {\n    type plug\n    slave.pcm \"multi_out\"\n}\n" >> "$ASOUNDRC"

elif [ $DEVICE_COUNT -eq 2 ]; then
    echo "Configuring dual-output audio with dmix..."
    cat > "$ASOUNDRC" << 'ASOUND_HEADER'
# ALSA config - auto-generated (2 devices with dmix)
ASOUND_HEADER

    SLAVE_IDX=0
    SLAVE_LETTERS=("a" "b")
    
    for dev_info in "analog:hw:0,0:1024" "usb:hw:1,0:1025" "hdmi0:hw:0,3:1026" "hdmi1:hw:0,7:1027" "hdmi2:hw:0,8:1028"; do
        IFS=: read -r dev_name hw_dev ipc_key <<< "$dev_info"
        var="HAS_$(echo $dev_name | tr '[:lower:]' '[:upper:]')"
        eval "has_dev=\$$var" 2>/dev/null || has_dev=0
        if [ "$has_dev" = "1" ] 2>/dev/null; then
            cat >> "$ASOUNDRC" << EOF
pcm.dmix_${dev_name} {
    type dmix
    ipc_key ${ipc_key}
    slave { pcm "${hw_dev}"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.plug_${dev_name} { type plug; slave.pcm "dmix_${dev_name}" }
EOF
        fi
    done

    # Build multi route for 2 devices
    SLAVE_IDX=0
    MULTI_SLAVES=""
    MULTI_BINDINGS=""
    TTABLE=""
    for dev in analog usb hdmi0 hdmi1 hdmi2; do
        var="HAS_$(echo $dev | tr '[:lower:]' '[:upper:]')"
        eval "has_dev=\$$var" 2>/dev/null || has_dev=0
        if [ "$has_dev" = "1" ] 2>/dev/null; then
            letter=${SLAVE_LETTERS[$SLAVE_IDX]}
            chan_start=$((SLAVE_IDX * 2))
            MULTI_SLAVES="${MULTI_SLAVES}        slaves.${letter}.pcm \"plug_${dev}\"\n        slaves.${letter}.channels 2\n"
            MULTI_BINDINGS="${MULTI_BINDINGS}        bindings.${chan_start}.slave ${letter}\n        bindings.${chan_start}.channel 0\n        bindings.$((chan_start+1)).slave ${letter}\n        bindings.$((chan_start+1)).channel 1\n"
            TTABLE="${TTABLE}    ttable.0.${chan_start} 1\n    ttable.1.$((chan_start+1)) 1\n"
            SLAVE_IDX=$((SLAVE_IDX + 1))
        fi
    done
    printf "pcm.multi_out {\n    type route\n    slave.pcm {\n        type multi\n${MULTI_SLAVES}${MULTI_BINDINGS}    }\n${TTABLE}}\n\npcm.!default {\n    type plug\n    slave.pcm \"multi_out\"\n}\n" >> "$ASOUNDRC"

elif [ $DEVICE_COUNT -eq 1 ]; then
    echo "Configuring single-output audio with dmix..."
    if [ $HAS_HDMI0 -eq 1 ]; then
        cat > "$ASOUNDRC" << 'EOF'
pcm.dmix_hdmi0 {
    type dmix
    ipc_key 1026
    slave { pcm "hw:0,3"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.!default { type plug; slave.pcm "dmix_hdmi0" }
EOF
    elif [ $HAS_HDMI1 -eq 1 ]; then
        cat > "$ASOUNDRC" << 'EOF'
pcm.dmix_hdmi1 {
    type dmix
    ipc_key 1027
    slave { pcm "hw:0,7"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.!default { type plug; slave.pcm "dmix_hdmi1" }
EOF
    elif [ $HAS_HDMI2 -eq 1 ]; then
        cat > "$ASOUNDRC" << 'EOF'
pcm.dmix_hdmi2 {
    type dmix
    ipc_key 1028
    slave { pcm "hw:0,8"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.!default { type plug; slave.pcm "dmix_hdmi2" }
EOF
    elif [ $HAS_ANALOG -eq 1 ]; then
        cat > "$ASOUNDRC" << 'EOF'
pcm.dmix_analog {
    type dmix
    ipc_key 1024
    slave { pcm "hw:0,0"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.!default { type plug; slave.pcm "dmix_analog" }
EOF
    elif [ $HAS_USB_AUDIO -eq 1 ]; then
        cat > "$ASOUNDRC" << 'EOF'
pcm.dmix_usb {
    type dmix
    ipc_key 1025
    slave { pcm "hw:1,0"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.!default { type plug; slave.pcm "dmix_usb" }
EOF
    fi
else
    echo "WARNING: No audio devices detected, using fallback (hw:0,3)..."
    cat > "$ASOUNDRC" << 'EOF'
pcm.dmix_fallback {
    type dmix
    ipc_key 1026
    slave { pcm "hw:0,3"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.!default { type plug; slave.pcm "dmix_fallback" }
EOF
fi

echo "Generated ALSA config at: $ASOUNDRC"

# ─── Unmute audio controls ────────────────────────────────────────────────────
echo "Unmuting audio controls..."
amixer -c 0 sset Master unmute 100% 2>/dev/null || true
for i in 0 1 2; do
    amixer -c 0 sset "IEC958,$i" unmute 2>/dev/null || true
done
[ $HAS_USB_AUDIO -eq 1 ] && amixer -c 1 sset PCM unmute 100% 2>/dev/null || true

# ─── Export ALSA config path ──────────────────────────────────────────────────
export ALSA_CONFIG_PATH="$ASOUNDRC"

# ─── Wayland / Display ────────────────────────────────────────────────────────
# Wait briefly for ubuntu-frame compositor to be ready
sleep 2

echo "WAYLAND_DISPLAY=$WAYLAND_DISPLAY"
echo "XDG_RUNTIME_DIR=$XDG_RUNTIME_DIR"

# ─── Find and launch Electron app ─────────────────────────────────────────────
# electron-packager output directory
ELECTRON_APP=$(find "$SNAP/electron-app" -maxdepth 1 -type d -name "cluemaster-*" | head -n 1)

if [ -z "$ELECTRON_APP" ]; then
    echo "ERROR: Could not find Electron app directory in $SNAP/electron-app"
    ls -la "$SNAP/electron-app/" 2>/dev/null || true
    exit 1
fi

ELECTRON_BIN="$ELECTRON_APP/cluemaster-timerdisplay"

if [ ! -f "$ELECTRON_BIN" ]; then
    # Try alternate name patterns
    ELECTRON_BIN=$(find "$ELECTRON_APP" -maxdepth 1 -type f -executable -name "cluemaster*" | head -n 1)
fi

if [ -z "$ELECTRON_BIN" ] || [ ! -f "$ELECTRON_BIN" ]; then
    echo "ERROR: Could not find Electron binary in $ELECTRON_APP"
    ls -la "$ELECTRON_APP/" 2>/dev/null || true
    exit 1
fi

echo "Launching: apulse $ELECTRON_BIN"

# Launch with apulse (PulseAudio emulation over ALSA - required for Chromium)
exec "$SNAP/usr/bin/apulse" "$ELECTRON_BIN" "$@"
