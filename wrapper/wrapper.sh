#!/bin/bash
# ═══════════════════════════════════════════════════════════════════════════════
# ClueMaster Timer Display - Linux/SNAP Wrapper Script
# ═══════════════════════════════════════════════════════════════════════════════
#
# This script:
# 1. Configures ALSA audio with dmix for concurrent audio streams
# 2. Sets up environment variables for Wayland/ubuntu-frame
# 3. Unmutes audio outputs
# 4. Launches Electron via apulse (PulseAudio emulation over ALSA)
#
# dmix is REQUIRED so that multiple audio streams (background music + clue
# alert + TTS speech + video audio) can play simultaneously without
# "Device or resource busy" errors.
# ═══════════════════════════════════════════════════════════════════════════════

set -e

echo "=== ClueMaster Timer Display Wrapper ==="
echo "SNAP=$SNAP"
echo "SNAP_USER_DATA=$SNAP_USER_DATA"

# ─── Ensure temp directory exists ──────────────────────────────────────────────
# Chromium uses TMPDIR when --disable-dev-shm-usage is set (instead of /dev/shm)
mkdir -p "$SNAP_USER_DATA/tmp" 2>/dev/null || true
chmod 1777 "$SNAP_USER_DATA/tmp" 2>/dev/null || true
export TMPDIR="$SNAP_USER_DATA/tmp"

# ─── D-Bus workaround ─────────────────────────────────────────────────────────
# Ubuntu Core daemons run without a session bus, causing Chromium to log errors.
# Setting to a valid-format but non-existent socket prevents parse errors.
# Chromium will silently fail to connect instead of crashing on parse.
export DBUS_SESSION_BUS_ADDRESS="unix:path=/dev/null"
export NO_AT_BRIDGE=1
export GTK_A11Y=none
export AT_SPI2_CORE_NO_DBUS=1

# ─── GLib/GIO D-Bus suppression ───────────────────────────────────────────────
# Tell GIO/GLib to skip D-Bus entirely
export GIO_USE_VFS=local
export GVFS_DISABLE_FUSE=1

# Disable portal/D-Bus features in GTK and other libraries
export GTK_USE_PORTAL=0
export GDK_DEBUG=no-portals

# Use malloc allocator to avoid potential issues with GLib memory pools
export G_SLICE=always-malloc
# Don't make GLib warnings fatal
export G_DEBUG=""

# ─── ALSA / dmix Audio Configuration ──────────────────────────────────────────
ASOUNDRC="$SNAP_USER_DATA/.asoundrc"

echo "Detecting audio devices..."

# Auto-detect available PCM devices from /proc/asound/pcm
HAS_ANALOG=0; HAS_USB_AUDIO=0; HAS_HDMI0=0; HAS_HDMI1=0; HAS_HDMI2=0

if [ -f /proc/asound/pcm ]; then
    echo "Available PCM devices:"
    cat /proc/asound/pcm
    grep -q "^00-00:.*playback" /proc/asound/pcm && HAS_ANALOG=1
    grep -q "^01-00:.*playback" /proc/asound/pcm && HAS_USB_AUDIO=1
    grep -q "^00-03:.*playback" /proc/asound/pcm && HAS_HDMI0=1
    grep -q "^00-07:.*playback" /proc/asound/pcm && HAS_HDMI1=1
    grep -q "^00-08:.*playback" /proc/asound/pcm && HAS_HDMI2=1
else
    echo "WARNING: /proc/asound/pcm not found"
fi

DEVICE_COUNT=$((HAS_ANALOG + HAS_USB_AUDIO + HAS_HDMI0 + HAS_HDMI1 + HAS_HDMI2))
echo "Detected $DEVICE_COUNT audio output(s): analog=$HAS_ANALOG usb=$HAS_USB_AUDIO hdmi0=$HAS_HDMI0 hdmi1=$HAS_HDMI1 hdmi2=$HAS_HDMI2"

# Generate .asoundrc with dmix for each detected device
# Each dmix MUST have a UNIQUE ipc_key for shared memory!

if [ $DEVICE_COUNT -ge 3 ]; then
    echo "Configuring multi-output audio with dmix (3+ devices)..."
    # Build the multi-output config dynamically
    cat > "$ASOUNDRC" << 'ASOUND_HEADER'
# ALSA config - auto-generated by ClueMaster Timer Display wrapper
# dmix enables concurrent audio streams (background music + alerts + TTS)
ASOUND_HEADER

    # Add dmix + plug for each detected device
    if [ $HAS_ANALOG -eq 1 ]; then
        cat >> "$ASOUNDRC" << 'EOF'
pcm.dmix_analog {
    type dmix
    ipc_key 1024
    slave { pcm "hw:0,0"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.plug_analog { type plug; slave.pcm "dmix_analog" }
EOF
    fi

    if [ $HAS_USB_AUDIO -eq 1 ]; then
        cat >> "$ASOUNDRC" << 'EOF'
pcm.dmix_usb {
    type dmix
    ipc_key 1025
    slave { pcm "hw:1,0"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.plug_usb { type plug; slave.pcm "dmix_usb" }
EOF
    fi

    if [ $HAS_HDMI0 -eq 1 ]; then
        cat >> "$ASOUNDRC" << 'EOF'
pcm.dmix_hdmi0 {
    type dmix
    ipc_key 1026
    slave { pcm "hw:0,3"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.plug_hdmi0 { type plug; slave.pcm "dmix_hdmi0" }
EOF
    fi

    if [ $HAS_HDMI1 -eq 1 ]; then
        cat >> "$ASOUNDRC" << 'EOF'
pcm.dmix_hdmi1 {
    type dmix
    ipc_key 1027
    slave { pcm "hw:0,7"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.plug_hdmi1 { type plug; slave.pcm "dmix_hdmi1" }
EOF
    fi

    if [ $HAS_HDMI2 -eq 1 ]; then
        cat >> "$ASOUNDRC" << 'EOF'
pcm.dmix_hdmi2 {
    type dmix
    ipc_key 1028
    slave { pcm "hw:0,8"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.plug_hdmi2 { type plug; slave.pcm "dmix_hdmi2" }
EOF
    fi

    # Build multi-output route device
    # Determine slave list and routing table dynamically
    SLAVE_IDX=0
    SLAVE_LETTERS=("a" "b" "c" "d" "e")
    MULTI_SLAVES=""
    MULTI_BINDINGS=""
    TTABLE=""
    
    for dev in analog usb hdmi0 hdmi1 hdmi2; do
        var="HAS_$(echo $dev | tr '[:lower:]' '[:upper:]')"
        # Bash indirection
        eval "has_dev=\$$var" 2>/dev/null || has_dev=0
        if [ "$has_dev" = "1" ] 2>/dev/null; then
            letter=${SLAVE_LETTERS[$SLAVE_IDX]}
            chan_start=$((SLAVE_IDX * 2))
            MULTI_SLAVES="${MULTI_SLAVES}        slaves.${letter}.pcm \"plug_${dev}\"\n        slaves.${letter}.channels 2\n"
            MULTI_BINDINGS="${MULTI_BINDINGS}        bindings.${chan_start}.slave ${letter}\n        bindings.${chan_start}.channel 0\n        bindings.$((chan_start+1)).slave ${letter}\n        bindings.$((chan_start+1)).channel 1\n"
            TTABLE="${TTABLE}    ttable.0.${chan_start} 1\n    ttable.1.$((chan_start+1)) 1\n"
            SLAVE_IDX=$((SLAVE_IDX + 1))
        fi
    done
    
    printf "pcm.multi_out {\n    type route\n    slave.pcm {\n        type multi\n${MULTI_SLAVES}${MULTI_BINDINGS}    }\n${TTABLE}}\n\npcm.!default {\n    type plug\n    slave.pcm \"multi_out\"\n}\n" >> "$ASOUNDRC"

elif [ $DEVICE_COUNT -eq 2 ]; then
    echo "Configuring dual-output audio with dmix..."
    cat > "$ASOUNDRC" << 'ASOUND_HEADER'
# ALSA config - auto-generated (2 devices with dmix)
ASOUND_HEADER

    SLAVE_IDX=0
    SLAVE_LETTERS=("a" "b")
    
    for dev_info in "analog:hw:0,0:1024" "usb:hw:1,0:1025" "hdmi0:hw:0,3:1026" "hdmi1:hw:0,7:1027" "hdmi2:hw:0,8:1028"; do
        IFS=: read -r dev_name hw_dev ipc_key <<< "$dev_info"
        var="HAS_$(echo $dev_name | tr '[:lower:]' '[:upper:]')"
        eval "has_dev=\$$var" 2>/dev/null || has_dev=0
        if [ "$has_dev" = "1" ] 2>/dev/null; then
            cat >> "$ASOUNDRC" << EOF
pcm.dmix_${dev_name} {
    type dmix
    ipc_key ${ipc_key}
    slave { pcm "${hw_dev}"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.plug_${dev_name} { type plug; slave.pcm "dmix_${dev_name}" }
EOF
        fi
    done

    # Build multi route for 2 devices
    SLAVE_IDX=0
    MULTI_SLAVES=""
    MULTI_BINDINGS=""
    TTABLE=""
    for dev in analog usb hdmi0 hdmi1 hdmi2; do
        var="HAS_$(echo $dev | tr '[:lower:]' '[:upper:]')"
        eval "has_dev=\$$var" 2>/dev/null || has_dev=0
        if [ "$has_dev" = "1" ] 2>/dev/null; then
            letter=${SLAVE_LETTERS[$SLAVE_IDX]}
            chan_start=$((SLAVE_IDX * 2))
            MULTI_SLAVES="${MULTI_SLAVES}        slaves.${letter}.pcm \"plug_${dev}\"\n        slaves.${letter}.channels 2\n"
            MULTI_BINDINGS="${MULTI_BINDINGS}        bindings.${chan_start}.slave ${letter}\n        bindings.${chan_start}.channel 0\n        bindings.$((chan_start+1)).slave ${letter}\n        bindings.$((chan_start+1)).channel 1\n"
            TTABLE="${TTABLE}    ttable.0.${chan_start} 1\n    ttable.1.$((chan_start+1)) 1\n"
            SLAVE_IDX=$((SLAVE_IDX + 1))
        fi
    done
    printf "pcm.multi_out {\n    type route\n    slave.pcm {\n        type multi\n${MULTI_SLAVES}${MULTI_BINDINGS}    }\n${TTABLE}}\n\npcm.!default {\n    type plug\n    slave.pcm \"multi_out\"\n}\n" >> "$ASOUNDRC"

elif [ $DEVICE_COUNT -eq 1 ]; then
    echo "Configuring single-output audio with dmix..."
    if [ $HAS_HDMI0 -eq 1 ]; then
        cat > "$ASOUNDRC" << 'EOF'
pcm.dmix_hdmi0 {
    type dmix
    ipc_key 1026
    slave { pcm "hw:0,3"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.!default { type plug; slave.pcm "dmix_hdmi0" }
EOF
    elif [ $HAS_HDMI1 -eq 1 ]; then
        cat > "$ASOUNDRC" << 'EOF'
pcm.dmix_hdmi1 {
    type dmix
    ipc_key 1027
    slave { pcm "hw:0,7"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.!default { type plug; slave.pcm "dmix_hdmi1" }
EOF
    elif [ $HAS_HDMI2 -eq 1 ]; then
        cat > "$ASOUNDRC" << 'EOF'
pcm.dmix_hdmi2 {
    type dmix
    ipc_key 1028
    slave { pcm "hw:0,8"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.!default { type plug; slave.pcm "dmix_hdmi2" }
EOF
    elif [ $HAS_ANALOG -eq 1 ]; then
        cat > "$ASOUNDRC" << 'EOF'
pcm.dmix_analog {
    type dmix
    ipc_key 1024
    slave { pcm "hw:0,0"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.!default { type plug; slave.pcm "dmix_analog" }
EOF
    elif [ $HAS_USB_AUDIO -eq 1 ]; then
        cat > "$ASOUNDRC" << 'EOF'
pcm.dmix_usb {
    type dmix
    ipc_key 1025
    slave { pcm "hw:1,0"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.!default { type plug; slave.pcm "dmix_usb" }
EOF
    fi
else
    echo "WARNING: No audio devices detected, using fallback (hw:0,3)..."
    cat > "$ASOUNDRC" << 'EOF'
pcm.dmix_fallback {
    type dmix
    ipc_key 1026
    slave { pcm "hw:0,3"; period_size 1024; buffer_size 4096; rate 48000 }
}
pcm.!default { type plug; slave.pcm "dmix_fallback" }
EOF
fi

echo "Generated ALSA config at: $ASOUNDRC"

# ─── Unmute audio controls ────────────────────────────────────────────────────
echo "Unmuting audio controls..."
amixer -c 0 sset Master unmute 100% 2>/dev/null || true
for i in 0 1 2; do
    amixer -c 0 sset "IEC958,$i" unmute 2>/dev/null || true
done
[ $HAS_USB_AUDIO -eq 1 ] && amixer -c 1 sset PCM unmute 100% 2>/dev/null || true

# ─── Export ALSA config path ──────────────────────────────────────────────────
export ALSA_CONFIG_PATH="$ASOUNDRC"

# ─── Wayland / Display ────────────────────────────────────────────────────────
# snapd remaps XDG_RUNTIME_DIR for confined snaps (e.g. /run/user/0/snap.<snapname>)
# The wayland plug, when connected, bind-mounts the compositor socket into this dir.
# We trust whatever snapd sets for XDG_RUNTIME_DIR - don't override it.

echo "XDG_RUNTIME_DIR=$XDG_RUNTIME_DIR"
echo "WAYLAND_DISPLAY=${WAYLAND_DISPLAY:-<unset>}"

# Set WAYLAND_DISPLAY default if not set
if [ -z "$WAYLAND_DISPLAY" ]; then
    export WAYLAND_DISPLAY="wayland-0"
fi

# ─── Search for Wayland socket ────────────────────────────────────────────────
# The socket could be in several locations depending on how ubuntu-frame
# and snapd expose it. Search common paths.
find_wayland_socket() {
    # 1. Standard location: $XDG_RUNTIME_DIR/$WAYLAND_DISPLAY
    if [ -n "$XDG_RUNTIME_DIR" ] && [ -S "$XDG_RUNTIME_DIR/$WAYLAND_DISPLAY" ]; then
        echo "$XDG_RUNTIME_DIR/$WAYLAND_DISPLAY"
        return 0
    fi
    
    # 2. Search for any wayland socket in XDG_RUNTIME_DIR
    if [ -n "$XDG_RUNTIME_DIR" ] && [ -d "$XDG_RUNTIME_DIR" ]; then
        local found
        found=$(find "$XDG_RUNTIME_DIR" -maxdepth 1 -name "wayland-*" -type s 2>/dev/null | head -n 1)
        if [ -n "$found" ]; then
            echo "$found"
            return 0
        fi
    fi
    
    # 3. Check /run/user/0 directly (non-snap-remapped path)
    if [ -S "/run/user/0/$WAYLAND_DISPLAY" ]; then
        echo "/run/user/0/$WAYLAND_DISPLAY"
        return 0
    fi
    
    # 4. Search /run/user/0 for any wayland socket
    if [ -d "/run/user/0" ]; then
        local found
        found=$(find /run/user/0 -maxdepth 2 -name "wayland-*" -type s 2>/dev/null | head -n 1)
        if [ -n "$found" ]; then
            echo "$found"
            return 0
        fi
    fi
    
    return 1
}

echo "Searching for Wayland socket..."
echo "Contents of XDG_RUNTIME_DIR ($XDG_RUNTIME_DIR):"
ls -la "$XDG_RUNTIME_DIR/" 2>/dev/null || echo "  (directory not found or not accessible)"
echo "Contents of /run/user/0/:"
ls -la /run/user/0/ 2>/dev/null || echo "  (directory not found or not accessible)"

# Wait for Wayland socket to appear (up to 60s - ubuntu-frame may take time)
WAIT_COUNT=0
WAYLAND_SOCKET=""
while [ $WAIT_COUNT -lt 60 ]; do
    WAYLAND_SOCKET=$(find_wayland_socket)
    if [ -n "$WAYLAND_SOCKET" ]; then
        break
    fi
    sleep 1
    WAIT_COUNT=$((WAIT_COUNT + 1))
    # Print diagnostics every 10 seconds
    if [ $((WAIT_COUNT % 10)) -eq 0 ]; then
        echo "Waiting for Wayland compositor... ($WAIT_COUNT/60)"
        echo "  XDG_RUNTIME_DIR contents:"
        ls -la "$XDG_RUNTIME_DIR/" 2>/dev/null || echo "    (not accessible)"
        echo "  /run/user/0 contents:"
        ls -la /run/user/0/ 2>/dev/null || echo "    (not accessible)"
    fi
done

if [ -n "$WAYLAND_SOCKET" ]; then
    echo "Wayland socket found at: $WAYLAND_SOCKET (after ${WAIT_COUNT}s)"
    
    # If the socket is not at the expected $XDG_RUNTIME_DIR/$WAYLAND_DISPLAY,
    # set WAYLAND_DISPLAY to the absolute path so Electron can find it
    EXPECTED_SOCKET="$XDG_RUNTIME_DIR/$WAYLAND_DISPLAY"
    if [ "$WAYLAND_SOCKET" != "$EXPECTED_SOCKET" ]; then
        echo "Socket not at expected path, setting WAYLAND_DISPLAY to absolute path"
        export WAYLAND_DISPLAY="$WAYLAND_SOCKET"
    fi
else
    echo "============================================================"
    echo "ERROR: No Wayland socket found after 60 seconds!"
    echo ""
    echo "Checklist:"
    echo "  1. Is ubuntu-frame installed?  snap list ubuntu-frame"
    echo "  2. Is ubuntu-frame running?    snap services ubuntu-frame"
    echo "  3. Is wayland interface connected?"
    echo "     snap connect cluemaster-mediadisplay-core:wayland ubuntu-frame"
    echo "  4. Check ubuntu-frame logs:    snap logs ubuntu-frame -n 50"
    echo ""
    echo "Debug info:"
    echo "  XDG_RUNTIME_DIR=$XDG_RUNTIME_DIR"
    ls -laR /run/user/ 2>/dev/null || echo "  /run/user/ not accessible"
    echo "============================================================"
fi

# ─── Find and launch Electron app ─────────────────────────────────────────────
# electron-packager output directory
ELECTRON_APP=$(find "$SNAP/electron-app" -maxdepth 1 -type d -name "cluemaster-*" | head -n 1)

if [ -z "$ELECTRON_APP" ]; then
    echo "ERROR: Could not find Electron app directory in $SNAP/electron-app"
    ls -la "$SNAP/electron-app/" 2>/dev/null || true
    exit 1
fi

ELECTRON_BIN="$ELECTRON_APP/cluemaster-timer"

if [ ! -f "$ELECTRON_BIN" ]; then
    # Try alternate name patterns
    ELECTRON_BIN=$(find "$ELECTRON_APP" -maxdepth 1 -type f -executable -name "cluemaster*" | head -n 1)
fi

if [ -z "$ELECTRON_BIN" ] || [ ! -f "$ELECTRON_BIN" ]; then
    echo "ERROR: Could not find Electron binary in $ELECTRON_APP"
    ls -la "$ELECTRON_APP/" 2>/dev/null || true
    exit 1
fi

echo "Launching: apulse $ELECTRON_BIN"

# ─── Launch Electron with Chromium flags for snap confinement ─────────────────
# Pass directly on command line - matches working VideoPlayer-Electron config.
# D-Bus errors are unavoidable in daemon mode but harmless - filter them from logs.
# Use apulse to provide PulseAudio API that redirects to ALSA
# (Chromium/Electron requires PulseAudio, but apulse emulates it using ALSA)
APULSE="$SNAP/usr/bin/apulse"
if [ -x "$APULSE" ]; then
    echo "Starting Electron with apulse (PulseAudio->ALSA wrapper)..."
    exec $APULSE "$ELECTRON_BIN" \
      --enable-features=UseOzonePlatform,VaapiVideoDecoder,VaapiVideoEncoder,VaapiVideoDecodeLinuxGL,PlatformHEVCDecoderSupport,PlatformHEVCEncoderSupport \
      --disable-features=Accessibility,AccessibilityARIAVirtualContent,AccessibilityObjectModel,HardwareMediaKeyHandling,MediaSessionService,SystemNotifications,GlobalMediaControls,AudioServiceOutOfProcess \
      --ozone-platform=wayland \
      --enable-wayland-ime \
      --no-sandbox \
      --disable-setuid-sandbox \
      --disable-gpu-sandbox \
      --no-zygote \
      --disable-dev-shm-usage \
      --use-gl=angle \
      --use-angle=gles \
      --enable-accelerated-video-decode \
      --disable-dbus \
      --force-renderer-accessibility=off \
      "$@" \
      2>&1 | grep --line-buffered -v "dbus/bus.cc\|dbus/object_proxy.cc"
else
    echo "WARNING: apulse not found, audio may not work!"
    echo "Starting Electron without audio wrapper..."
    exec "$ELECTRON_BIN" \
      --enable-features=UseOzonePlatform,VaapiVideoDecoder,VaapiVideoEncoder,VaapiVideoDecodeLinuxGL,PlatformHEVCDecoderSupport,PlatformHEVCEncoderSupport \
      --disable-features=Accessibility,AccessibilityARIAVirtualContent,AccessibilityObjectModel,HardwareMediaKeyHandling,MediaSessionService,SystemNotifications,GlobalMediaControls,AudioServiceOutOfProcess \
      --ozone-platform=wayland \
      --enable-wayland-ime \
      --no-sandbox \
      --disable-setuid-sandbox \
      --disable-gpu-sandbox \
      --no-zygote \
      --disable-dev-shm-usage \
      --use-gl=angle \
      --use-angle=gles \
      --enable-accelerated-video-decode \
      --disable-dbus \
      --force-renderer-accessibility=off \
      "$@" \
      2>&1 | grep --line-buffered -v "dbus/bus.cc\|dbus/object_proxy.cc"
fi
